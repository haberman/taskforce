
#ifndef __TASKFORCE_H__
#define __TASKFORCE_H__

#include <memory>
#include <queue>
#include <set>
#include <string>
#include <unordered_map>

namespace taskforce {

class Job;
class StrArr;
class Task;
class TaskForceProto;

class TaskForce {
 public:
  // Initializes the graph of tasks.
  //
  // If there was an error in the input tasks, returns false and writes an
  // error message.
  bool Initialize(std::unique_ptr<TaskForceProto> taskforce,
                  std::string* error);

  // Attempts to build everything, returning true if this succeeded.
  bool Build();

 private:
  bool SpawnJob(taskforce::Job* job);

  struct FileInfo {
    std::string sha1;
    bool is_source;  // False if generated by a task.
  };

  // Proto representing this TaskForce.
  std::unique_ptr<TaskForceProto> proto_;

  // The base environment that is applied to every task's run.
  std::unique_ptr<StrArr> base_env_;

  // Maps task_id -> Task*.
  std::unordered_map<std::string, const Task*> tasks_;

  // Maps each filename to the task that produces it.
  std::unordered_map<std::string, const Task*> task_producing_;

  // An ordering of the tasks that will always build dependencies before they
  // are used.
  std::vector<const Task*> topo_order_;

  //std::queue<taskforce::Job*> runqueue_;
  //std::set<taskforce::Job*> running_;
  //std::map<std::string, taskforce::Job*> jobs_;
};

}

#endif
